#!/usr/bin/env node
'use strict';

var program = require('commander');
var build = require('../lib/build');
var gulp = require('gulp');
var livereload = require('gulp-livereload');
var getConfig = require('../lib/config').get;
var _ = require('lodash');
var log = require('../lib/log');
var file = require('spm').sdk.file;

var p = file.readJSON('package.json');
if (!p || !p.spm) {
  log.error('miss', 'package.json or "spm" key');
  process.exit(1);
}

program
  .option('-w, --watch', 'watch for file changes and rebuild automatically')
  .option('-p, --publish', 'build for publish')
  .parse(process.argv);

var opt = _.extend(getConfig(), {
  publish: program.publish
});

buildWrap(function() {
  if (!program.watch) return;
  log.header('watch', 'enabled');

  setTimeout(function() {
    var timer;
    gulp.watch([opt.watch].concat('./package.json'), function(file) {
      log.header('file changed', file.path);
      timer && clearTimeout(timer);
      timer = setTimeout(buildWrap, 500);
    });
  }, 100);

  // livereload
  if (opt.livereload) {
    var server = livereload();
    gulp.watch(opt.dest + '**', function(file) {
      log.info('livereload', file.path);
      server.changed(file.path);
    });
  }
});

function buildWrap(cb) {
  var begin = new Date();
  var _gulp = new gulp.Gulp();

  _gulp.task('prepare', function() {
    begin = new Date();
  });

  build(opt, _gulp, function(err) {
    if (err) {
      log.error('error', err.message);
      log.debug('error', err.stack);
    } else {
      log.info('finish', showDiff(begin));
    }
  });

  cb && cb();
}

function showDiff(time) {
  var diff = Date.now() - time;
  return (' (' + diff + 'ms)').to.gray.color;
}
